Running Tests:

The library and tests require ruby 1.9 or higher. Run the tests as:

ruby1.9.1 tests/test_filemanager.rb

Bencoding: ruby gem bencode


Ideas:

Use the reactor for the network sockets. Apparently using non-blocking IO for files is useless: http://www.remlab.net/op/nonblock.shtml
Files are always readable and writable. However the task is paused when reading or writing to a file that needs to be swapped in. So it
might be worthwhile to do reading and writing in a different thread.

The file io thread would have a queue for requests, and would write responses into a queue as events. The reactor would pick up the events
which are 'block ready' or 'write complete' (Why write complete?). In the coroutine, the handler would match the event to the io that 
cared about it and deal with this event.

TODO
  - Shutdown never completes
  - Update peer download rate when they download msgs
  - On startup we should focus on completing at least one piece instead of trying to download a lot of different pieces.
  - Currently when we request blocks we request a fixed amount from the first peer returned from the findRequestableBlocks
    call. We should spread the requests out to other peers as well if we have saturated the first peer's connection.
    We could tell by the peer's upload rate: upload_rate/(block_size/request_blocks_period) is the ratio of peer's measured
    upload versus our expected upload based on our requests. If this ratio is 1 we are requesting at the rate that the 
    peer can upload to us. If it is < 0 we are requesting faster than the peer can provide. We can keep increasing the
    amount we request from the peer as long as the ratio stays at almost 1. If it drops below a threshold then we should scale
    back our requesting.

      upload_rate/(block_size/request_blocks_period)

  - Limit peers to the target peer count
  - Need to timeout when reading messages. For example, when receiving an incoming handshake
    if it's the tracker testing us then we don't get a peerid. In this case we will block forever 
    trying to read it.
  - Currently we accept connections from peers even when we are checking the piece hash. Is this a problem?
    
 

TESTING:

  - Test peerclient downloading a piece with an invalid hash.


--------------

Test 1:

kanobe@andor:~/src/rubytorrentlib$ ruby1.9.1 src/peerclient.rb /tmp/newtorrent/DW\ Statcards\ Pages.zip.torrent
kanobe@andor:~/src/rubytorrentlib$ tests/framework/run_testtorrent_tracker.rb
kanobe@andor:~/src/rubytorrentlib$ ruby1.9.1 src/peerclient.rb --basedir tmp/client2/ --port 9997 /tmp/newtorrent/DW\ Statcards\ Pages.zip.torrent

------

Curses download interface:

  - Like rtorrent
  - list torrents being downloaded, and user can select to
    get details screen.
  - Summary per torrent:
    active peer count, total peer count, unckoked/choked/interested/not interested peer counts, rates



