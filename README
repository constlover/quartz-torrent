Running Tests:

The library and tests require ruby 1.9 or higher. Run the tests as:

ruby1.9.1 tests/test_filemanager.rb

Bencoding: ruby gem bencode


Ideas:

Use the reactor for the network sockets. Apparently using non-blocking IO for files is useless: http://www.remlab.net/op/nonblock.shtml
Files are always readable and writable. However the task is paused when reading or writing to a file that needs to be swapped in. So it
might be worthwhile to do reading and writing in a different thread.

The file io thread would have a queue for requests, and would write responses into a queue as events. The reactor would pick up the events
which are 'block ready' or 'write complete' (Why write complete?). In the coroutine, the handler would match the event to the io that 
cared about it and deal with this event.

TODO
  - Currently we are assuming that we will only have one Peer object for each peer, but that's not true. We could get one
    from the tracker, and one from an incoming request that have different ports (one is the port we would connect to, and 
    one is the port they connect to us using). We need to check the places where we search for peers by id to make sure 
    they make sense.
  - Currently when we request blocks we request a fixed amount from the first peer returned from the findRequestableBlocks
    call. We should spread the requests out to other peers as well if we have saturated the first peer's connection.
    We could tell by the peer's upload rate: upload_rate/(block_size/request_blocks_period) is the ratio of peer's measured
    upload versus our expected upload based on our requests. If this ratio is 1 we are requesting at the rate that the 
    peer can upload to us. If it is < 0 we are requesting faster than the peer can provide. We can keep increasing the
    amount we request from the peer as long as the ratio stays at almost 1. If it drops below a threshold then we should scale
    back our requesting.

      upload_rate/(block_size/request_blocks_period)


  - Send bitmap on handshake completion
  - Send have messages
  - Need to timeout when reading messages. For example, when receiving an incoming handshake
    if it's the tracker testing us then we don't get a peerid. In this case we will block forever 
    trying to read it.

TESTING:

  - Test peerclient downloading a piece with an invalid hash.


--------------

Test 1:

kanobe@andor:~/src/rubytorrentlib$ ruby1.9.1 src/peerclient.rb /tmp/newtorrent/DW\ Statcards\ Pages.zip.torrent
kanobe@andor:~/src/rubytorrentlib$ tests/framework/run_testtorrent_tracker.rb
kanobe@andor:~/src/rubytorrentlib$ ruby1.9.1 src/peerclient.rb --basedir tmp/client2/ --port 9997 /tmp/newtorrent/DW\ Statcards\ Pages.zip.torrent


Bug in piece 400:
  - /tmp/piece: From torrent client (bad)
  - /tmp/piece2: from real archive (good)

  - Difference starts at offset 0001c000
  - The part beginning at 0001c000 in piece2 starts at 0001c09a in piece. 
  - Seems like the calculation for the final offset in peerclient was too high.
  - blocks are length 0x4000, ans 0001c000/4000 = 7, so problem is in 8th (final) block
  - Request for that block is piece 400 offset 114688 length 2727
  - Basically the problem is that I am treating the length in the request message as the block length
    when really it is the length of the request. The filemanager class expects calls to be made using index of 
    the block, when in this case there is no way to tell. Need to recode the filemanager classes to handle arbitrary lengths.




